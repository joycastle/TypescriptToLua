"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
var ts = require("typescript");
var TSHelper_1 = require("./TSHelper");
var path = require("path");
/* tslint:disable */
var packageJSON = require("../package.json");
/* tslint:enable */
var TranspileError = /** @class */ (function (_super) {
    __extends(TranspileError, _super);
    function TranspileError(message, node) {
        var _this = _super.call(this, message) || this;
        _this.node = node;
        return _this;
    }
    return TranspileError;
}(Error));
exports.TranspileError = TranspileError;
var LuaTarget;
(function (LuaTarget) {
    LuaTarget["Lua51"] = "5.1";
    LuaTarget["Lua52"] = "5.2";
    LuaTarget["Lua53"] = "5.3";
    LuaTarget["LuaJIT"] = "JIT";
})(LuaTarget = exports.LuaTarget || (exports.LuaTarget = {}));
var LuaTranspiler = /** @class */ (function () {
    function LuaTranspiler(checker, options, sourceFile) {
        this.indent = "";
        this.checker = checker;
        this.options = options;
        this.genVarCounter = 0;
        this.transpilingSwitch = 0;
        this.namespace = [];
        this.importCount = 0;
        this.sourceFile = sourceFile;
        this.isModule = TSHelper_1.TSHelper.isFileModule(sourceFile);
        this.loopStack = [];
        this.classStack = [];
    }
    LuaTranspiler.prototype.pushIndent = function () {
        this.indent = this.indent + "    ";
    };
    LuaTranspiler.prototype.popIndent = function () {
        this.indent = this.indent.slice(4);
    };
    LuaTranspiler.prototype.definitionName = function (name) {
        return this.namespace.concat(name).join(".");
    };
    LuaTranspiler.prototype.accessPrefix = function (node) {
        return node && (this.isModule || this.namespace.length > 0) ?
            "local " : "";
    };
    LuaTranspiler.prototype.makeExport = function (name, node, dummy) {
        var result = "";
        if (node &&
            node.modifiers && this.isModule &&
            (ts.getCombinedModifierFlags(node) & ts.ModifierFlags.Export)) {
            if (dummy) {
                result = this.indent + ("exports." + this.definitionName(name) + " = {}\n");
            }
            else {
                result = this.indent + ("exports." + this.definitionName(name) + " = " + name + "\n");
            }
        }
        if (this.namespace.length !== 0 && !ts.isModuleDeclaration(node)) {
            if (dummy) {
                result += this.indent + (this.definitionName(name) + " = {}\n");
            }
            else {
                result += this.indent + (this.definitionName(name) + " = " + name + "\n");
            }
        }
        return result;
    };
    LuaTranspiler.prototype.getAbsouluteImportPath = function (relativePath) {
        if (relativePath.charAt(0) !== "." && this.options.baseUrl) {
            return path.resolve(this.options.baseUrl, relativePath);
        }
        return path.resolve(path.dirname(this.sourceFile.fileName), relativePath);
    };
    LuaTranspiler.prototype.getImportPath = function (relativePath) {
        // Calculate absolute path to import
        var absolutePathToImport = this.getAbsouluteImportPath(relativePath);
        if (this.options.rootDir) {
            // Calculate path realtive to project root
            // and replace path.sep with dots (lua doesn't know paths)
            var relativePathToRoot = this.pathToLuaRequirePath(absolutePathToImport.replace(this.options.rootDir, "").slice(1));
            return "\"" + relativePathToRoot + "\"";
        }
        return "\"" + this.pathToLuaRequirePath(relativePath) + "\"";
    };
    LuaTranspiler.prototype.pathToLuaRequirePath = function (filePath) {
        return filePath.replace(new RegExp("\\\\|\/", "g"), ".");
    };
    // Transpile a source file
    LuaTranspiler.prototype.transpileSourceFile = function () {
        var _this = this;
        var header = "";
        if (this.options.addHeader) {
            header = "-- Generated by TypescriptToLua v" + packageJSON.version + "\n" +
                "-- https://github.com/Perryvw/TypescriptToLua\n";
        }
        var result = header;
        if (!this.options.dontRequireLuaLib) {
            // require helper functions
            result += "require(\"typescript_lualib\")\n";
        }
        if (this.isModule) {
            // Shadow exports if it already exists
            result += "local exports = exports or {}\n";
        }
        // Transpile content statements
        this.sourceFile.statements.forEach(function (s) { return result += _this.transpileNode(s); });
        if (this.isModule) {
            result += "return exports\n";
        }
        return result;
    };
    // Transpile a block
    LuaTranspiler.prototype.transpileBlock = function (block) {
        var _this = this;
        return block.statements.map(function (statement) { return _this.transpileNode(statement); }).join("");
    };
    // Transpile a node of unknown kind.
    LuaTranspiler.prototype.transpileNode = function (node) {
        // Ignore declarations
        if (node.modifiers && node.modifiers.some(function (modifier) { return modifier.kind === ts.SyntaxKind.DeclareKeyword; })) {
            return "";
        }
        switch (node.kind) {
            case ts.SyntaxKind.ImportDeclaration:
                return this.transpileImport(node);
            case ts.SyntaxKind.ClassDeclaration:
                return this.transpileClass(node);
            case ts.SyntaxKind.ModuleDeclaration:
                return this.transpileNamespace(node);
            case ts.SyntaxKind.ModuleBlock:
                return this.transpileBlock(node);
            case ts.SyntaxKind.EnumDeclaration:
                return this.transpileEnum(node);
            case ts.SyntaxKind.FunctionDeclaration:
                return this.transpileFunctionDeclaration(node);
            case ts.SyntaxKind.VariableStatement:
                return this.indent +
                    this.transpileVariableStatement(node) + "\n";
            case ts.SyntaxKind.ExpressionStatement:
                return this.indent +
                    this.transpileExpression(node.expression) + "\n";
            case ts.SyntaxKind.ReturnStatement:
                return this.indent + this.transpileReturn(node) + "\n";
            case ts.SyntaxKind.IfStatement:
                return this.transpileIf(node);
            case ts.SyntaxKind.WhileStatement:
                return this.transpileWhile(node);
            case ts.SyntaxKind.DoStatement:
                return this.transpileDoStatement(node);
            case ts.SyntaxKind.ForStatement:
                return this.transpileFor(node);
            case ts.SyntaxKind.ForOfStatement:
                return this.transpileForOf(node);
            case ts.SyntaxKind.ForInStatement:
                return this.transpileForIn(node);
            case ts.SyntaxKind.SwitchStatement:
                return this.transpileSwitch(node);
            case ts.SyntaxKind.BreakStatement:
                return this.transpileBreak();
            case ts.SyntaxKind.TryStatement:
                return this.transpileTry(node);
            case ts.SyntaxKind.ThrowStatement:
                return this.transpileThrow(node);
            case ts.SyntaxKind.ContinueStatement:
                return this.transpileContinue(node);
            case ts.SyntaxKind.TypeAliasDeclaration:
            case ts.SyntaxKind.InterfaceDeclaration:
            case ts.SyntaxKind.EndOfFileToken:
                // Ignore these
                return "";
            default:
                return this.indent + this.transpileExpression(node) + "\n";
        }
    };
    LuaTranspiler.prototype.transpileImport = function (node) {
        var importPath = this.transpileExpression(node.moduleSpecifier);
        var importPathWithoutQuotes = importPath.replace(new RegExp("\"", "g"), "");
        if (!node.importClause || !node.importClause.namedBindings) {
            throw new TranspileError("Default Imports are not supported, please use named imports instead!", node);
        }
        var imports = node.importClause.namedBindings;
        if (ts.isNamedImports(imports)) {
            var fileImportTable_1 = path.basename(importPathWithoutQuotes) + this.importCount;
            var resolvedImportPath = this.getImportPath(importPathWithoutQuotes);
            var result_1 = "local " + fileImportTable_1 + " = require(" + resolvedImportPath + ")\n";
            this.importCount++;
            imports.elements.forEach(function (element) {
                var nameText = element.name.escapedText;
                if (element.propertyName) {
                    result_1 +=
                        "local " + nameText + " = " + fileImportTable_1 + "." + element.propertyName.escapedText + "\n";
                }
                else {
                    result_1 +=
                        "local " + nameText + " = " + fileImportTable_1 + "." + element.name.escapedText + "\n";
                }
            });
            return result_1;
        }
        else if (ts.isNamespaceImport(imports)) {
            var resolvedImportPath = this.getImportPath(importPathWithoutQuotes);
            return "local " + imports.name.escapedText + " = require(" + resolvedImportPath + ")\n";
        }
        else {
            throw new TranspileError("Unsupported import type.", node);
        }
    };
    LuaTranspiler.prototype.transpileNamespace = function (node) {
        // If phantom namespace just transpile the body as normal
        if (TSHelper_1.TSHelper.isPhantom(this.checker.getTypeAtLocation(node), this.checker) && node.body) {
            return this.transpileNode(node.body);
        }
        var defName = this.definitionName(node.name.text);
        var result = this.indent +
            this.accessPrefix(node) +
            (node.name.text + " = " + node.name.text + " or {}\n");
        if (this.namespace.length > 0) {
            result += this.indent + (defName + " = " + node.name.text + " or {}\n");
        }
        result += this.makeExport(defName, node);
        // Create closure
        result += this.indent + "do\n";
        this.pushIndent();
        this.namespace.push(node.name.text);
        if (node.body) {
            result += this.transpileNode(node.body);
        }
        this.namespace.pop();
        this.popIndent();
        result += this.indent + "end\n";
        return result;
    };
    LuaTranspiler.prototype.transpileEnum = function (node) {
        var _this = this;
        var val = 0;
        var result = "";
        var type = this.checker.getTypeAtLocation(node);
        var membersOnly = TSHelper_1.TSHelper.isCompileMembersOnlyEnum(type, this.checker);
        if (!membersOnly) {
            var name_1 = node.name.escapedText;
            result += this.indent + this.accessPrefix(node) + (name_1 + "={}\n");
            result += this.makeExport(name_1, node);
        }
        var hasStringInitializers = false;
        node.members.forEach(function (member) {
            if (member.initializer) {
                if (ts.isNumericLiteral(member.initializer)) {
                    val = parseInt(member.initializer.text);
                }
                else if (ts.isStringLiteral(member.initializer)) {
                    hasStringInitializers = true;
                    val = "\"" + member.initializer.text + "\"";
                }
                else {
                    throw new TranspileError("Only numeric or string initializers allowed for enums.", node);
                }
            }
            else if (hasStringInitializers) {
                throw new TranspileError("Invalid heterogeneous enum.", node);
            }
            if (membersOnly) {
                var defName = _this.definitionName(member.name.escapedText);
                result += _this.indent + (defName + "=" + val + "\n");
            }
            else {
                var defName = _this.definitionName(node.name.escapedText + "." + member.name.escapedText);
                result += _this.indent + (defName + "=" + val + "\n");
            }
            if (typeof val === "number") {
                val++;
            }
        });
        return result;
    };
    LuaTranspiler.prototype.transpileBreak = function () {
        if (this.transpilingSwitch > 0) {
            return "";
        }
        else {
            return this.indent + "break\n";
        }
    };
    LuaTranspiler.prototype.transpileContinue = function (node) {
        throw new TranspileError("Unsupported continue statement, " +
            ("continue is not supported in Lua " + this.options.luaTarget + "."), node);
    };
    LuaTranspiler.prototype.transpileIf = function (node) {
        var condition = this.transpileExpression(node.expression);
        var result = this.indent + ("if " + condition + " then\n");
        this.pushIndent();
        result += this.transpileStatement(node.thenStatement);
        this.popIndent();
        if (node.elseStatement) {
            result += this.indent + "else\n";
            this.pushIndent();
            result += this.transpileStatement(node.elseStatement);
            this.popIndent();
        }
        return result + this.indent + "end\n";
    };
    LuaTranspiler.prototype.transpileLoopBody = function (node) {
        this.loopStack.push(this.genVarCounter);
        this.genVarCounter++;
        var result = this.indent + "do\n";
        this.pushIndent();
        result += this.transpileStatement(node.statement);
        this.popIndent();
        result += this.indent + "end\n";
        return result;
    };
    LuaTranspiler.prototype.transpileWhile = function (node) {
        var condition = this.transpileExpression(node.expression);
        var result = this.indent + ("while " + condition + " do\n");
        this.pushIndent();
        result += this.transpileLoopBody(node);
        this.popIndent();
        return result + this.indent + "end\n";
    };
    LuaTranspiler.prototype.transpileDoStatement = function (node) {
        var result = this.indent + "repeat\n";
        this.pushIndent();
        result += this.transpileLoopBody(node);
        this.popIndent();
        // Negate the expression because we translate from do-while to repeat-until (repeat-while-not)
        result += this.indent + ("until not " + this.transpileExpression(node.expression, true) + "\n");
        return result;
    };
    LuaTranspiler.prototype.transpileFor = function (node) {
        // Add header
        var result = "";
        for (var _i = 0, _a = node.initializer.declarations; _i < _a.length; _i++) {
            var variableDeclaration = _a[_i];
            result += this.indent + this.transpileVariableDeclaration(variableDeclaration);
        }
        result += this.indent + ("while(" + this.transpileExpression(node.condition) + ") do\n");
        // Add body
        this.pushIndent();
        result += this.transpileLoopBody(node);
        result += this.indent + this.transpileExpression(node.incrementor) + "\n";
        this.popIndent();
        result += this.indent + "end\n";
        return result;
    };
    LuaTranspiler.prototype.transpileForOf = function (node) {
        // Get variable identifier
        var variable = node.initializer.declarations[0];
        var identifier = variable.name;
        // Transpile expression
        var expression = this.transpileExpression(node.expression);
        // Use ipairs for array types, pairs otherwise
        var isArray = TSHelper_1.TSHelper.isArrayType(this.checker.getTypeAtLocation(node.expression), this.checker);
        var pairs = isArray ? "ipairs" : "pairs";
        // Make header
        var result = this.indent + ("for _, " + identifier.escapedText + " in " + pairs + "(" + expression + ") do\n");
        // For body
        this.pushIndent();
        result += this.transpileLoopBody(node);
        this.popIndent();
        return result + this.indent + "end\n";
    };
    LuaTranspiler.prototype.transpileForIn = function (node) {
        // Get variable identifier
        var variable = node.initializer.declarations[0];
        var identifier = variable.name;
        // Transpile expression
        var expression = this.transpileExpression(node.expression);
        if (TSHelper_1.TSHelper.isArrayType(this.checker.getTypeAtLocation(node.expression), this.checker)) {
            throw new TranspileError("Iterating over arrays with 'for in' is not allowed.", node);
        }
        // Make header
        var result = this.indent + ("for " + identifier.escapedText + ", _ in pairs(" + expression + ") do\n");
        // For body
        this.pushIndent();
        result += this.transpileLoopBody(node);
        this.popIndent();
        return result + this.indent + "end\n";
    };
    LuaTranspiler.prototype.transpileStatement = function (node) {
        if (ts.isBlock(node)) {
            return this.transpileBlock(node);
        }
        else {
            return this.transpileNode(node);
        }
    };
    LuaTranspiler.prototype.transpileSwitch = function (node) {
        var _this = this;
        var expression = this.transpileExpression(node.expression, true);
        var clauses = node.caseBlock.clauses;
        var result = this.indent + "-------Switch statement start-------\n";
        var jumpTableName = "____switch" + this.genVarCounter;
        this.genVarCounter++;
        result += this.indent + ("local " + jumpTableName + " = {}\n");
        // If statement to go to right entry label
        clauses.forEach(function (clause, index) {
            if (ts.isCaseClause(clause)) {
                result += _this.indent + "-- case:\n";
                result += _this.indent +
                    (jumpTableName + "[" + _this.transpileExpression(clause.expression, true) + "] = function()\n");
            }
            if (ts.isDefaultClause(clause)) {
                result += _this.indent + "-- default:\n";
                result += _this.indent + (jumpTableName + "[\"____default" + _this.genVarCounter + "\"] = function()\n");
            }
            _this.pushIndent();
            _this.transpilingSwitch++;
            clause.statements.forEach(function (statement) {
                result += _this.transpileNode(statement);
            });
            _this.transpilingSwitch--;
            var i = index + 1;
            if (i < clauses.length && !TSHelper_1.TSHelper.containsStatement(clause.statements, ts.SyntaxKind.BreakStatement)) {
                var nextClause = clauses[i];
                while (i < clauses.length
                    && ts.isCaseClause(nextClause)
                    && nextClause.statements.length === 0) {
                    i++;
                    nextClause = clauses[i];
                }
                if (i !== index && nextClause) {
                    if (ts.isCaseClause(nextClause)) {
                        result += _this.indent +
                            (jumpTableName + "[" + _this.transpileExpression(nextClause.expression, true) + "]()\n");
                    }
                    else {
                        result += _this.indent + (jumpTableName + "[\"____default" + _this.genVarCounter + "\"]()\n");
                    }
                }
            }
            else {
                result += _this.indent + "-- break;\n";
            }
            _this.popIndent();
            result += _this.indent + "end\n";
        });
        result += this.indent +
            ("if " + jumpTableName + "[" + expression + "] then " + jumpTableName + "[" + expression + "]()\n");
        result += this.indent +
            ("elseif " + jumpTableName + "[\"____default" + this.genVarCounter + "\"] ") +
            ("then " + jumpTableName + "[\"____default" + this.genVarCounter + "\"]() end\n");
        result += this.indent +
            "--------Switch statement end--------\n";
        // Increment counter for next switch statement
        this.genVarCounter += clauses.length;
        return result;
    };
    LuaTranspiler.prototype.transpileTry = function (node) {
        var tryFunc = "function()\n";
        this.pushIndent();
        tryFunc += this.transpileBlock(node.tryBlock);
        this.popIndent();
        tryFunc += "end";
        var catchFunc = "function(e)\nend";
        if (node.catchClause && node.catchClause.variableDeclaration) {
            var variableName = node.catchClause.variableDeclaration.name.escapedText;
            catchFunc = this.indent + ("function(" + variableName + ")\n");
            this.pushIndent();
            catchFunc += this.transpileBlock(node.catchClause.block);
            this.popIndent();
            catchFunc += "end";
        }
        var result = this.indent + ("xpcall(" + tryFunc + ",\n" + catchFunc + ")\n");
        if (node.finallyBlock) {
            result += this.transpileBlock(node.finallyBlock);
        }
        return result;
    };
    LuaTranspiler.prototype.transpileThrow = function (node) {
        if (ts.isStringLiteral(node.expression)) {
            return "error(\"" + node.expression.text + "\")";
        }
        else {
            throw new TranspileError("Unsupported throw expression, only string literals are supported", node.expression);
        }
    };
    LuaTranspiler.prototype.transpileReturn = function (node) {
        var _this = this;
        if (node.expression) {
            // If parent function is a TupleReturn function
            // and return expression is an array literal, leave out brackets.
            var declaration = TSHelper_1.TSHelper.findFirstNodeAbove(node, ts.isFunctionDeclaration);
            if (declaration && TSHelper_1.TSHelper.isTupleReturnFunction(this.checker.getTypeAtLocation(declaration), this.checker)
                && ts.isArrayLiteralExpression(node.expression)) {
                return "return " + node.expression.elements.map(function (elem) { return _this.transpileExpression(elem); }).join(",");
            }
            // Otherwise just do a normal return
            return "return " + this.transpileExpression(node.expression);
        }
        else {
            return "return";
        }
    };
    LuaTranspiler.prototype.transpileExpression = function (node, brackets) {
        switch (node.kind) {
            case ts.SyntaxKind.BinaryExpression:
                // Add brackets to preserve ordering
                return this.transpileBinaryExpression(node, brackets);
            case ts.SyntaxKind.ConditionalExpression:
                // Add brackets to preserve ordering
                return this.transpileConditionalExpression(node, brackets);
            case ts.SyntaxKind.CallExpression:
                return this.transpileCallExpression(node);
            case ts.SyntaxKind.PropertyAccessExpression:
                return this.transpilePropertyAccessExpression(node);
            case ts.SyntaxKind.ElementAccessExpression:
                return this.transpileElementAccessExpression(node);
            case ts.SyntaxKind.Identifier:
                // Catch undefined which is passed as identifier
                if (node.originalKeywordKind === ts.SyntaxKind.UndefinedKeyword) {
                    return "nil";
                }
                // Otherwise simply return the name
                return node.text;
            case ts.SyntaxKind.StringLiteral:
            case ts.SyntaxKind.NoSubstitutionTemplateLiteral:
                var text = node.text;
                return "\"" + text + "\"";
            case ts.SyntaxKind.TemplateExpression:
                return this.transpileTemplateExpression(node);
            case ts.SyntaxKind.NumericLiteral:
                return node.text;
            case ts.SyntaxKind.TrueKeyword:
                return "true";
            case ts.SyntaxKind.FalseKeyword:
                return "false";
            case ts.SyntaxKind.NullKeyword:
            case ts.SyntaxKind.UndefinedKeyword:
                return "nil";
            case ts.SyntaxKind.ThisKeyword:
                return "self";
            case ts.SyntaxKind.PostfixUnaryExpression:
                return this.transpilePostfixUnaryExpression(node);
            case ts.SyntaxKind.PrefixUnaryExpression:
                return this.transpilePrefixUnaryExpression(node);
            case ts.SyntaxKind.ArrayLiteralExpression:
                return this.transpileArrayLiteral(node);
            case ts.SyntaxKind.ObjectLiteralExpression:
                return this.transpileObjectLiteral(node);
            case ts.SyntaxKind.DeleteExpression:
                return this.transpileExpression(node.expression) + "=nil";
            case ts.SyntaxKind.FunctionExpression:
            case ts.SyntaxKind.ArrowFunction:
                return this.transpileFunctionExpression(node);
            case ts.SyntaxKind.NewExpression:
                return this.transpileNewExpression(node);
            case ts.SyntaxKind.ComputedPropertyName:
                return "[" + this.transpileExpression(node.expression) + "]";
            case ts.SyntaxKind.ParenthesizedExpression:
                return "(" + this.transpileExpression(node.expression) + ")";
            case ts.SyntaxKind.SuperKeyword:
                return "self.__base";
            case ts.SyntaxKind.TypeAssertionExpression:
                // Simply ignore the type assertion
                return this.transpileExpression(node.expression);
            case ts.SyntaxKind.AsExpression:
                // Also ignore as casts
                return this.transpileExpression(node.expression);
            case ts.SyntaxKind.TypeOfExpression:
                return this.transpileTypeOfExpression(node);
            default:
                throw new TranspileError("Unsupported expression kind: " + TSHelper_1.TSHelper.enumName(node.kind, ts.SyntaxKind), node);
        }
    };
    LuaTranspiler.prototype.transpileBinaryExpression = function (node, brackets) {
        // Transpile operands
        var lhs = this.transpileExpression(node.left, true);
        var rhs = this.transpileExpression(node.right, true);
        // Check if this is an assignment token, then handle accordingly
        var _a = TSHelper_1.TSHelper.isBinaryAssignmentToken(node.operatorToken.kind), isAssignment = _a[0], operator = _a[1];
        if (isAssignment) {
            var valueExpression = ts.createBinary(node.left, operator, node.right);
            var value = this.transpileBinaryExpression(valueExpression);
            if (TSHelper_1.TSHelper.hasSetAccessor(node.left, this.checker)) {
                return this.transpileSetAccessor(node.left, value);
            }
            return lhs + " = " + value;
        }
        var result = "";
        // Transpile Bitops
        switch (node.operatorToken.kind) {
            case ts.SyntaxKind.AmpersandToken:
            case ts.SyntaxKind.BarToken:
            case ts.SyntaxKind.CaretToken:
            case ts.SyntaxKind.LessThanLessThanToken:
            case ts.SyntaxKind.GreaterThanGreaterThanToken:
            case ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken:
                result = this.transpileBitOperation(node, lhs, rhs);
        }
        // Transpile operators
        if (result === "") {
            switch (node.operatorToken.kind) {
                case ts.SyntaxKind.AmpersandAmpersandToken:
                    result = lhs + " and " + rhs;
                    break;
                case ts.SyntaxKind.BarBarToken:
                    result = lhs + " or " + rhs;
                    break;
                case ts.SyntaxKind.PlusToken:
                    // Replace string + with ..
                    var typeLeft = this.checker.getTypeAtLocation(node.left);
                    var typeRight = this.checker.getTypeAtLocation(node.right);
                    if ((typeLeft.flags & ts.TypeFlags.String) || ts.isStringLiteral(node.left)
                        || (typeRight.flags & ts.TypeFlags.String) || ts.isStringLiteral(node.right)) {
                        return lhs + " .. " + rhs;
                    }
                    result = lhs + "+" + rhs;
                    break;
                case ts.SyntaxKind.MinusToken:
                    result = lhs + "-" + rhs;
                    break;
                case ts.SyntaxKind.AsteriskToken:
                    result = lhs + "*" + rhs;
                    break;
                case ts.SyntaxKind.AsteriskAsteriskToken:
                    result = lhs + "^" + rhs;
                    break;
                case ts.SyntaxKind.SlashToken:
                    result = lhs + "/" + rhs;
                    break;
                case ts.SyntaxKind.PercentToken:
                    result = lhs + "%" + rhs;
                    break;
                case ts.SyntaxKind.GreaterThanToken:
                    result = lhs + ">" + rhs;
                    break;
                case ts.SyntaxKind.GreaterThanEqualsToken:
                    result = lhs + ">=" + rhs;
                    break;
                case ts.SyntaxKind.LessThanToken:
                    result = lhs + "<" + rhs;
                    break;
                case ts.SyntaxKind.LessThanEqualsToken:
                    result = lhs + "<=" + rhs;
                    break;
                case ts.SyntaxKind.EqualsToken:
                    if (TSHelper_1.TSHelper.hasSetAccessor(node.left, this.checker)) {
                        return this.transpileSetAccessor(node.left, rhs);
                    }
                    result = lhs + " = " + rhs;
                    break;
                case ts.SyntaxKind.EqualsEqualsToken:
                case ts.SyntaxKind.EqualsEqualsEqualsToken:
                    result = lhs + "==" + rhs;
                    break;
                case ts.SyntaxKind.ExclamationEqualsToken:
                case ts.SyntaxKind.ExclamationEqualsEqualsToken:
                    result = lhs + "~=" + rhs;
                    break;
                case ts.SyntaxKind.InKeyword:
                    result = rhs + "[" + lhs + "]~=nil";
                    break;
                case ts.SyntaxKind.InstanceOfKeyword:
                    result = "TS_instanceof(" + lhs + ", " + rhs + ")";
                    break;
                default:
                    throw new TranspileError("Unsupported binary operator kind: " + ts.tokenToString(node.operatorToken.kind), node);
            }
        }
        // Optionally put brackets around result
        if (brackets) {
            return "(" + result + ")";
        }
        else {
            return result;
        }
    };
    LuaTranspiler.prototype.transpileUnaryBitOperation = function (node, operand) {
        throw new TranspileError("Bit operations are not supported in Lua " + this.options.target, node);
    };
    LuaTranspiler.prototype.transpileBitOperation = function (node, lhs, rhs) {
        throw new TranspileError("Bit operations are not supported in Lua " + this.options.target, node);
    };
    LuaTranspiler.prototype.transpileTemplateExpression = function (node) {
        var _this = this;
        var parts = ["\"" + node.head.text + "\""];
        node.templateSpans.forEach(function (span) {
            var expr = _this.transpileExpression(span.expression, true);
            if (ts.isTemplateTail(span.literal)) {
                parts.push("tostring(" + expr + ")..\"" + span.literal.text + "\"");
            }
            else {
                parts.push("tostring(" + expr + ")..\"" + span.literal.text + "\"");
            }
        });
        return parts.join("..");
    };
    LuaTranspiler.prototype.transpileConditionalExpression = function (node, brackets) {
        var condition = this.transpileExpression(node.condition);
        var val1 = this.transpileExpression(node.whenTrue);
        var val2 = this.transpileExpression(node.whenFalse);
        return "TS_ITE(" + condition + ",function() return " + val1 + " end,function() return " + val2 + " end)";
    };
    LuaTranspiler.prototype.transpilePostfixUnaryExpression = function (node) {
        var operand = this.transpileExpression(node.operand, true);
        switch (node.operator) {
            case ts.SyntaxKind.PlusPlusToken:
                return operand + "=" + operand + "+1";
            case ts.SyntaxKind.MinusMinusToken:
                return operand + "=" + operand + "-1";
            default:
                var operator = TSHelper_1.TSHelper.enumName(node.operator, ts.SyntaxKind);
                throw new TranspileError("Unsupported unary postfix: " + operator, node);
        }
    };
    LuaTranspiler.prototype.transpilePrefixUnaryExpression = function (node) {
        var operand = this.transpileExpression(node.operand, true);
        switch (node.operator) {
            case ts.SyntaxKind.TildeToken:
                return this.transpileUnaryBitOperation(node, operand);
            case ts.SyntaxKind.PlusPlusToken:
                return operand + "=" + operand + "+1";
            case ts.SyntaxKind.MinusMinusToken:
                return operand + "=" + operand + "-1";
            case ts.SyntaxKind.ExclamationToken:
                return "(not " + operand + ")";
            case ts.SyntaxKind.MinusToken:
                return "-" + operand;
            default:
                var operator = TSHelper_1.TSHelper.enumName(node.operator, ts.SyntaxKind);
                throw new TranspileError("Unsupported unary prefix: " + operator, node);
        }
    };
    LuaTranspiler.prototype.transpileNewExpression = function (node) {
        var name = this.transpileExpression(node.expression);
        var params = node.arguments ? this.transpileArguments(node.arguments, ts.createTrue()) : "true";
        return name + ".new(" + params + ")";
    };
    LuaTranspiler.prototype.transpileCallExpression = function (node) {
        // Check for calls on primitives to override
        var params;
        var callPath;
        var isTupleReturn = TSHelper_1.TSHelper.isTupleReturnCall(node, this.checker);
        var isInDestructingAssignment = TSHelper_1.TSHelper.isInDestructingAssignment(node);
        if (ts.isPropertyAccessExpression(node.expression)) {
            var result = this.transpilePropertyCall(node);
            return isTupleReturn && !isInDestructingAssignment ? "({ " + result + " })" : result;
        }
        // Handle super calls properly
        if (node.expression.kind === ts.SyntaxKind.SuperKeyword) {
            params = this.transpileArguments(node.arguments, ts.createNode(ts.SyntaxKind.ThisKeyword));
            var className = this.classStack[this.classStack.length - 1];
            return className + ".__base.constructor(" + params + ")";
        }
        callPath = this.transpileExpression(node.expression);
        params = this.transpileArguments(node.arguments);
        return isTupleReturn && !isInDestructingAssignment ? "({ " + callPath + "(" + params + ") })" : callPath + "(" + params + ")";
    };
    LuaTranspiler.prototype.transpilePropertyCall = function (node) {
        var params;
        var callPath;
        // Check if call is actually on a property access expression
        if (!ts.isPropertyAccessExpression(node.expression)) {
            throw new TranspileError("Tried to transpile a non-property call as property call.", node);
        }
        // If the function being called is of type owner.func, get the type of owner
        var ownerType = this.checker.getTypeAtLocation(node.expression.expression);
        if (ownerType.symbol && ownerType.symbol.escapedName === "Math") {
            params = this.transpileArguments(node.arguments);
            return this.transpileMathExpression(node.expression.name) + ("(" + params + ")");
        }
        if (this.transpileExpression(node.expression.expression) === "String") {
            params = this.transpileArguments(node.arguments);
            return this.transpileStringExpression(node.expression.name) + ("(" + params + ")");
        }
        switch (ownerType.flags) {
            case ts.TypeFlags.String:
            case ts.TypeFlags.StringLiteral:
                return this.transpileStringCallExpression(node);
        }
        if (TSHelper_1.TSHelper.isArrayType(ownerType, this.checker)) {
            return this.transpileArrayCallExpression(node);
        }
        // Get the type of the function
        var functionType = this.checker.getTypeAtLocation(node.expression);
        // Don't replace . with : for namespaces
        if ((ownerType.symbol && (ownerType.symbol.flags & ts.SymbolFlags.Namespace))
            // If function is defined as property with lambda type use . instead of :
            || (functionType.symbol && (functionType.symbol.flags & ts.SymbolFlags.TypeLiteral))) {
            callPath = this.transpileExpression(node.expression);
            params = this.transpileArguments(node.arguments);
            return callPath + "(" + params + ")";
        }
        else {
            // Replace last . with : here
            callPath =
                this.transpileExpression(node.expression.expression) + ":" + node.expression.name.escapedText;
            params = this.transpileArguments(node.arguments);
            return callPath + "(" + params + ")";
        }
    };
    LuaTranspiler.prototype.transpileStringCallExpression = function (node) {
        var expression = node.expression;
        var params = this.transpileArguments(node.arguments);
        var caller = this.transpileExpression(expression.expression);
        switch (expression.name.escapedText) {
            case "replace":
                return "TS_replace(" + caller + "," + params + ")";
            case "indexOf":
                if (node.arguments.length === 1) {
                    return "(string.find(" + caller + "," + params + ",1,true) or 0)-1";
                }
                else {
                    return "(string.find(" + caller + "," + params + "+1,true) or 0)-1";
                }
            case "substring":
                if (node.arguments.length === 1) {
                    return "string.sub(" + caller + "," + params + "+1)";
                }
                else {
                    var arg1 = this.transpileExpression(node.arguments[0]);
                    var arg2 = this.transpileExpression(node.arguments[1]);
                    return "string.sub(" + caller + "," + arg1 + "+1," + arg2 + ")";
                }
            case "toLowerCase":
                return "string.lower(" + caller + ")";
            case "toUpperCase":
                return "string.upper(" + caller + ")";
            case "split":
                return "TS_split(" + caller + "," + params + ")";
            case "charAt":
                return "string.sub(" + caller + "," + params + "+1," + params + "+1)";
            default:
                throw new TranspileError("Unsupported string function: " + expression.name.escapedText, node);
        }
    };
    LuaTranspiler.prototype.getValidStringProperties = function () {
        return {
            fromCharCode: "string.char"
        };
    };
    // Transpile a String._ property
    LuaTranspiler.prototype.transpileStringExpression = function (identifier) {
        var translation = this.getValidStringProperties();
        if (translation[identifier.escapedText]) {
            return "" + translation[identifier.escapedText];
        }
        else {
            throw new TranspileError("Unsupported string property " + identifier.escapedText + ", " +
                ("is not supported in Lua " + this.options.luaTarget + "."), identifier);
        }
    };
    LuaTranspiler.prototype.transpileArrayCallExpression = function (node) {
        var expression = node.expression;
        var params = this.transpileArguments(node.arguments);
        var caller = this.transpileExpression(expression.expression);
        switch (expression.name.escapedText) {
            case "push":
                return "TS_push(" + caller + ", " + params + ")";
            case "forEach":
                return "TS_forEach(" + caller + ", " + params + ")";
            case "indexOf":
                return "TS_indexOf(" + caller + ", " + params + ")";
            case "map":
                return "TS_map(" + caller + ", " + params + ")";
            case "filter":
                return "TS_filter(" + caller + ", " + params + ")";
            case "some":
                return "TS_some(" + caller + ", " + params + ")";
            case "every":
                return "TS_every(" + caller + ", " + params + ")";
            case "slice":
                return "TS_slice(" + caller + ", " + params + ")";
            case "splice":
                return "TS_splice(" + caller + ", " + params + ")";
            case "join":
                if (node.arguments.length === 0) {
                    // if seperator is omitted default seperator is ","
                    return "table.concat(" + caller + ", \",\")";
                }
                else {
                    return "table.concat(" + caller + ", " + params + ")";
                }
            default:
                throw new TranspileError("Unsupported array function: " + expression.name.escapedText, node);
        }
    };
    LuaTranspiler.prototype.transpileArguments = function (params, context) {
        var _this = this;
        var parameters = [];
        // Add context as first param if present
        if (context) {
            parameters.push(this.transpileExpression(context));
        }
        params.forEach(function (param) {
            parameters.push(_this.transpileExpression(param));
        });
        return parameters.join(",");
    };
    LuaTranspiler.prototype.transpilePropertyAccessExpression = function (node) {
        var property = node.name.text;
        // Check for primitive types to override
        var type = this.checker.getTypeAtLocation(node.expression);
        switch (type.flags) {
            case ts.TypeFlags.String:
            case ts.TypeFlags.StringLiteral:
                return this.transpileStringProperty(node);
            case ts.TypeFlags.Object:
                if (TSHelper_1.TSHelper.isArrayType(type, this.checker)) {
                    return this.transpileArrayProperty(node);
                }
                else if (TSHelper_1.TSHelper.hasGetAccessor(node, this.checker)) {
                    return this.transpileGetAccessor(node);
                }
        }
        // Do not output path for member only enums
        if (TSHelper_1.TSHelper.isCompileMembersOnlyEnum(type, this.checker)) {
            return property;
        }
        // Catch math expressions
        if (ts.isIdentifier(node.expression) && node.expression.escapedText === "Math") {
            return this.transpileMathExpression(node.name);
        }
        var callPath = this.transpileExpression(node.expression);
        return callPath + "." + property;
    };
    LuaTranspiler.prototype.transpileGetAccessor = function (node) {
        var name = node.name.escapedText;
        var expression = this.transpileExpression(node.expression);
        return expression + ":get__" + name + "()";
    };
    LuaTranspiler.prototype.transpileSetAccessor = function (node, value) {
        var name = node.name.escapedText;
        var expression = this.transpileExpression(node.expression);
        return expression + ":set__" + name + "(" + value + ")";
    };
    // Transpile a Math._ property
    LuaTranspiler.prototype.transpileMathExpression = function (identifier) {
        var translation = {
            PI: "pi",
            abs: "abs",
            acos: "acos",
            asin: "asin",
            atan: "atan",
            ceil: "ceil",
            cos: "cos",
            exp: "exp",
            floor: "floor",
            log: "log",
            max: "max",
            min: "min",
            pow: "pow",
            random: "random",
            round: "round",
            sin: "sin",
            sqrt: "sqrt",
            tan: "tan"
        };
        if (translation[identifier.escapedText]) {
            return "math." + translation[identifier.escapedText];
        }
        else {
            throw new TranspileError("Unsupported math property: " + identifier.escapedText + ".", identifier);
        }
    };
    // Transpile access of string properties, only supported properties are allowed
    LuaTranspiler.prototype.transpileStringProperty = function (node) {
        var property = node.name;
        switch (property.escapedText) {
            case "length":
                return "#" + this.transpileExpression(node.expression);
            default:
                throw new TranspileError("Unsupported string property: " + property.escapedText, node);
        }
    };
    // Transpile access of array properties, only supported properties are allowed
    LuaTranspiler.prototype.transpileArrayProperty = function (node) {
        var property = node.name;
        switch (property.escapedText) {
            case "length":
                return "#" + this.transpileExpression(node.expression);
            default:
                throw new TranspileError("Unsupported array property: " + property.escapedText, node);
        }
    };
    LuaTranspiler.prototype.transpileElementAccessExpression = function (node) {
        var element = this.transpileExpression(node.expression);
        var index = this.transpileExpression(node.argumentExpression);
        var type = this.checker.getTypeAtLocation(node.expression);
        if (TSHelper_1.TSHelper.isArrayType(type, this.checker)) {
            return element + "[" + index + "+1]";
        }
        else if (TSHelper_1.TSHelper.isStringType(type)) {
            return "string.sub(" + element + "," + index + "+1," + index + "+1)";
        }
        else {
            return element + "[" + index + "]";
        }
    };
    LuaTranspiler.prototype.transpileTypeOfExpression = function (node) {
        var expression = this.transpileExpression(node.expression);
        return "(type(" + expression + ") == \"table\" and \"object\" or type(" + expression + "))";
    };
    // Transpile a variable statement
    LuaTranspiler.prototype.transpileVariableStatement = function (node) {
        var _this = this;
        var result = "";
        node.declarationList.declarations.forEach(function (declaration) {
            result += _this.transpileVariableDeclaration(declaration);
            result += _this.makeExport(declaration.name.escapedText, node);
        });
        return result;
    };
    LuaTranspiler.prototype.transpileVariableDeclaration = function (node) {
        if (ts.isIdentifier(node.name)) {
            // Find variable identifier
            var identifier = node.name;
            if (node.initializer) {
                var value = this.transpileExpression(node.initializer);
                return "local " + identifier.escapedText + " = " + value + "\n";
            }
            else {
                return "local " + identifier.escapedText + " = nil\n";
            }
        }
        else if (ts.isArrayBindingPattern(node.name)) {
            // Destructuring type
            var value = this.transpileExpression(node.initializer);
            // Disallow ellipsis destruction
            if (node.name.elements.some(function (elem) { return !ts.isBindingElement(elem) || elem.dotDotDotToken !== undefined; })) {
                throw new TranspileError("Ellipsis destruction is not allowed.", node);
            }
            var vars = node.name.elements.map(function (element) { return element.name.escapedText; }).join(",");
            // Don't unpack TupleReturn decorated functions
            if (TSHelper_1.TSHelper.isTupleReturnCall(node.initializer, this.checker)) {
                return "local " + vars + "=" + value + "\n";
            }
            else {
                return "local " + vars + "=table.unpack(" + value + ")\n";
            }
        }
        else {
            throw new TranspileError("Unsupported variable declaration type: " + TSHelper_1.TSHelper.enumName(node.name.kind, ts.SyntaxKind), node);
        }
    };
    LuaTranspiler.prototype.transpileFunctionDeclaration = function (node) {
        // Don't transpile functions without body (overload declarations)
        if (!node.body) {
            return "";
        }
        var result = "";
        var identifier = node.name;
        var methodName = identifier.escapedText;
        var parameters = node.parameters;
        var body = node.body;
        // Build parameter string
        var paramNames = [];
        var spreadIdentifier = "";
        // Only push parameter name to paramName array if it isn't a spread parameter
        for (var _i = 0, parameters_1 = parameters; _i < parameters_1.length; _i++) {
            var param = parameters_1[_i];
            var paramName = param.name.escapedText;
            // This parameter is a spread parameter (...param)
            if (!param.dotDotDotToken) {
                paramNames.push(paramName);
            }
            else {
                spreadIdentifier = paramName;
                // Push the spread operator into the paramNames array
                paramNames.push("...");
            }
        }
        // Build function header
        result += this.indent + this.accessPrefix(node) + ("function " + methodName + "(" + paramNames.join(",") + ")\n");
        this.pushIndent();
        // Push spread operator here
        if (spreadIdentifier !== "") {
            result += this.indent + ("local " + spreadIdentifier + " = { ... }\n");
        }
        result += this.transpileBlock(body);
        this.popIndent();
        // Close function block
        result += this.indent + "end\n";
        result += this.makeExport(methodName, node);
        return result;
    };
    LuaTranspiler.prototype.transpileMethodDeclaration = function (node, callPath) {
        // Don't transpile methods without body (overload declarations)
        if (!node.body) {
            return "";
        }
        var result = "";
        var identifier = node.name;
        var methodName = identifier.escapedText;
        var parameters = node.parameters;
        var body = node.body;
        // Build parameter string
        var paramNames = ["self"];
        var spreadIdentifier = "";
        // Only push parameter name to paramName array if it isn't a spread parameter
        for (var _i = 0, parameters_2 = parameters; _i < parameters_2.length; _i++) {
            var param = parameters_2[_i];
            var paramName = param.name.escapedText;
            // This parameter is a spread parameter (...param)
            if (!param.dotDotDotToken) {
                paramNames.push(paramName);
            }
            else {
                spreadIdentifier = paramName;
                // Push the spread operator into the paramNames array
                paramNames.push("...");
            }
        }
        // Parameters with default values
        var defaultValueParams = node.parameters.filter(function (declaration) { return declaration.initializer !== undefined; });
        // Build function header
        result += this.indent + ("function " + callPath + methodName + "(" + paramNames.join(",") + ")\n");
        this.pushIndent();
        // Push spread operator here
        if (spreadIdentifier !== "") {
            result += this.indent + ("local " + spreadIdentifier + " = { ... }\n");
        }
        result += this.transpileParameterDefaultValues(defaultValueParams);
        result += this.transpileBlock(body);
        this.popIndent();
        // Close function block
        result += this.indent + "end\n";
        return result;
    };
    // Transpile a class declaration
    LuaTranspiler.prototype.transpileClass = function (node) {
        var _this = this;
        if (!node.name) {
            throw new TranspileError("Class declaration has no name.", node);
        }
        var className = node.name.escapedText;
        // Find out if this class is extension of exising class
        var isExtension = TSHelper_1.TSHelper.isExtensionClass(this.checker.getTypeAtLocation(node), this.checker);
        // Get type that is extended
        var extendsType = TSHelper_1.TSHelper.getExtendedType(node, this.checker);
        // Get all properties with value
        var properties = node.members.filter(ts.isPropertyDeclaration)
            .filter(function (member) { return member.initializer; });
        // Divide properties into static and non-static
        var isStatic = function (prop) { return prop.modifiers && prop.modifiers.some(function (m) { return m.kind === ts.SyntaxKind.StaticKeyword; }); };
        var staticFields = properties.filter(isStatic);
        var instanceFields = properties.filter(function (prop) { return !isStatic(prop); });
        var result = "";
        if (!isExtension) {
            result += this.transpileClassCreationMethods(node, instanceFields, extendsType);
        }
        else {
            // export empty table
            result += this.makeExport(className, node, true);
        }
        // Overwrite the original className with the class we are overriding for extensions
        if (isExtension && extendsType) {
            className = extendsType.symbol.escapedName;
        }
        // Add static declarations
        for (var _i = 0, staticFields_1 = staticFields; _i < staticFields_1.length; _i++) {
            var field = staticFields_1[_i];
            var fieldName = field.name.escapedText;
            var value = this.transpileExpression(field.initializer);
            result += this.indent + (className + "." + fieldName + " = " + value + "\n");
        }
        // Try to find constructor
        var constructor = node.members.filter(ts.isConstructorDeclaration)[0];
        if (constructor) {
            // Add constructor plus initialisation of instance fields
            result += this.transpileConstructor(constructor, className);
        }
        else if (!isExtension) {
            // Generate a constructor if none was defined
            result += this.transpileConstructor(ts.createConstructor([], [], [], ts.createBlock([], true)), className);
        }
        // Transpile get accessors
        node.members.filter(ts.isGetAccessor).forEach(function (getAccessor) {
            result += _this.transpileGetAccessorDeclaration(getAccessor, className);
        });
        // Transpile set accessors
        node.members.filter(ts.isSetAccessor).forEach(function (setAccessor) {
            result += _this.transpileSetAccessorDeclaration(setAccessor, className);
        });
        // Transpile methods
        node.members.filter(ts.isMethodDeclaration).forEach(function (method) {
            result += _this.transpileMethodDeclaration(method, className + ".");
        });
        return result;
    };
    LuaTranspiler.prototype.transpileClassCreationMethods = function (node, instanceFields, extendsType) {
        var className = node.name.escapedText;
        var noClassOr = extendsType && TSHelper_1.TSHelper.hasCustomDecorator(extendsType, this.checker, "!NoClassOr");
        var result = "";
        // Write class declaration
        var classOr = noClassOr ? "" : className + " or ";
        if (!extendsType) {
            result += this.indent + this.accessPrefix(node) + (className + " = " + classOr + "{}\n");
            result += this.makeExport(className, node);
        }
        else {
            var baseName = extendsType.symbol.escapedName;
            result += this.indent + this.accessPrefix(node) + (className + " = " + classOr + baseName + ".new()\n");
            result += this.makeExport(className, node);
        }
        result += this.indent + (className + ".__index = " + className + "\n");
        if (extendsType) {
            var baseName = extendsType.symbol.escapedName;
            result += this.indent + (className + ".__base = " + baseName + "\n");
        }
        result += this.indent + ("function " + className + ".new(construct, ...)\n");
        result += this.indent + ("    local instance = setmetatable({}, " + className + ")\n");
        for (var _i = 0, instanceFields_1 = instanceFields; _i < instanceFields_1.length; _i++) {
            var f = instanceFields_1[_i];
            // Get identifier
            var fieldIdentifier = f.name;
            var fieldName = fieldIdentifier.escapedText;
            var value = this.transpileExpression(f.initializer);
            result += this.indent + ("    instance." + fieldName + " = " + value + "\n");
        }
        result += this.indent + ("    if construct and " + className + ".constructor then ")
            + (className + ".constructor(instance, ...) end\n");
        result += this.indent + "    return instance\n";
        result += this.indent + "end\n";
        return result;
    };
    LuaTranspiler.prototype.transpileGetAccessorDeclaration = function (getAccessor, className) {
        var name = getAccessor.name.escapedText;
        var result = this.indent + ("function " + className + ".get__" + name + "(self)\n");
        this.pushIndent();
        result += this.transpileBlock(getAccessor.body);
        this.popIndent();
        result += this.indent + "end\n";
        return result;
    };
    LuaTranspiler.prototype.transpileSetAccessorDeclaration = function (setAccessor, className) {
        var name = setAccessor.name.escapedText;
        var paramNames = ["self"];
        setAccessor.parameters.forEach(function (param) {
            paramNames.push(param.name.escapedText);
        });
        var result = this.indent + ("function " + className + ".set__" + name + "(" + paramNames.join(",") + ")\n");
        this.pushIndent();
        result += this.transpileBlock(setAccessor.body);
        this.popIndent();
        result += this.indent + "end\n";
        return result;
    };
    LuaTranspiler.prototype.transpileConstructor = function (node, className) {
        var extraInstanceFields = [];
        var parameters = ["self"];
        node.parameters.forEach(function (param) {
            // If param has decorators, add extra instance field
            if (param.modifiers !== undefined) {
                extraInstanceFields.push(param.name.escapedText);
            }
            // Add to parameter list
            parameters.push(param.name.escapedText);
        });
        var result = this.indent + ("function " + className + ".constructor(" + parameters.join(",") + ")\n");
        // Add in instance field declarations
        for (var _i = 0, extraInstanceFields_1 = extraInstanceFields; _i < extraInstanceFields_1.length; _i++) {
            var f = extraInstanceFields_1[_i];
            result += this.indent + ("    self." + f + " = " + f + "\n");
        }
        // Transpile constructor body
        this.pushIndent();
        this.classStack.push(className);
        result += this.transpileBlock(node.body);
        this.classStack.pop();
        this.popIndent();
        return result + this.indent + "end\n";
    };
    LuaTranspiler.prototype.transpileArrayLiteral = function (node) {
        var _this = this;
        var values = [];
        node.elements.forEach(function (child) {
            values.push(_this.transpileExpression(child));
        });
        return "{" + values.join(",") + "}";
    };
    LuaTranspiler.prototype.transpileObjectLiteral = function (node) {
        var _this = this;
        var properties = [];
        // Add all property assignments
        node.properties.forEach(function (element) {
            var name = "";
            if (ts.isIdentifier(element.name)) {
                name = element.name.escapedText;
            }
            else if (ts.isComputedPropertyName(element.name)) {
                name = _this.transpileExpression(element.name);
            }
            else {
                name = "[" + _this.transpileExpression(element.name) + "]";
            }
            if (ts.isPropertyAssignment(element)) {
                var expression = _this.transpileExpression(element.initializer);
                properties.push(name + " = " + expression);
            }
            else {
                var elementKind = TSHelper_1.TSHelper.enumName(element.kind, ts.SyntaxKind);
                throw new TranspileError("Encountered unsupported object literal element: " + elementKind + ".", node);
            }
        });
        return "{" + properties.join(",") + "}";
    };
    LuaTranspiler.prototype.transpileFunctionExpression = function (node) {
        // Build parameter string
        var paramNames = [];
        node.parameters.forEach(function (param) {
            paramNames.push(param.name.escapedText);
        });
        var defaultValueParams = node.parameters.filter(function (declaration) { return declaration.initializer !== undefined; });
        if (ts.isBlock(node.body) || defaultValueParams.length > 0) {
            var result = "function(" + paramNames.join(",") + ")\n";
            this.pushIndent();
            result += this.transpileParameterDefaultValues(defaultValueParams);
            result += this.transpileBlock(node.body);
            this.popIndent();
            return result + this.indent + "end\n";
        }
        else {
            return "function(" + paramNames.join(",") + ") return " + this.transpileExpression(node.body) + " end";
        }
    };
    LuaTranspiler.prototype.transpileParameterDefaultValues = function (params) {
        var _this = this;
        var result = "";
        params.filter(function (declaration) { return declaration.initializer !== undefined; }).forEach(function (declaration) {
            var paramName = declaration.name.escapedText;
            var paramValue = _this.transpileExpression(declaration.initializer);
            result += _this.indent + ("if " + paramName + "==nil then " + paramName + "=" + paramValue + " end\n");
        });
        return result;
    };
    LuaTranspiler.AvailableLuaTargets = [LuaTarget.LuaJIT, LuaTarget.Lua53];
    return LuaTranspiler;
}());
exports.LuaTranspiler = LuaTranspiler;
//# sourceMappingURL=Transpiler.js.map